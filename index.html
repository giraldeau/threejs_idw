<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interpolation overlay demo</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #cccccc;
        font-family:Monospace;
        font-size:13px;
        text-align:center;

        background-color: #050505;
        margin: 0px;
        overflow: hidden;
      }

      #info {
        position: absolute;
        top: 0px; width: 100%;
        padding: 5px;
      }

      a {
        color: #0080ff;
      }

    </style>
</head>
<body>
<div id="container"></div>
<script src="bundle.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
  uniform float time;
  uniform vec2 resolution;
  attribute vec3 myColor;
  varying vec3 xColor;
  void main() {
    vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * modelViewPosition;
    //xColor = vec3(abs(gl_Position.x), abs(gl_Position.y), 0);
    xColor = vec3(myColor.x, 1.0, 0);
  }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
  uniform float time;
  uniform vec2 resolution;
  varying vec3 xColor;
  void main() {
    gl_FragColor = vec4(xColor, 0.5);
  }
</script>

<script>
  var container;
  var camera, scene, renderer;

  init();

  function init() {
    container = document.getElementById('container');

    scene = new THREE.Scene();
    var ww = window.innerWidth;
    var wh = window.innerHeight;
    camera = new THREE.OrthographicCamera(ww / -200, ww / 200, wh / -200, wh / 200, 0.1, 1000 );

    //var geometry = new THREE.PlaneGeometry(1, 1, 5, 5);
    //var geometry = new THREE.BoxGeometry(1, 1, 1);


    var vertices = new Float32Array( [
       0.0,  1.0,  0.0,
       1.0,  1.0,  0.0,
       1.0,  0.0,  0.0,
       2.0,  0.0,  0.0,
       2.0,  1.0,  0.0,
       3.0,  1.0,  0.0,
    ] );

    var colors = new Float32Array(
      1.0, 0.0, 0.0,
      0.0, 1.0, 0.0,
      0.0, 0.0, 1.0,
      1.0, 0.0, 1.0,
      0.0, 1.0, 1.0,
      1.0, 1.0, 1.0,
    );

    var v2D = [];
    for (var i = 0; i < vertices.length; i += 3) {
      var temp = [vertices[i], vertices[i + 1]];
      v2D.push(temp);
    }

    var triangles = triangulate(v2D);
    var trianglesIndices = [];
    for (var i = 0; i < triangles.length; i++) {
      var t = triangles[i];
      trianglesIndices.push(t[0], t[1], t[2]);
    }

    console.log(triangles);

    indices = new Uint32Array(trianglesIndices);

    // hardcoding the delaunay result for testing purpose
    var indicesFixed = new Uint32Array( [
      0, 1, 2, 2, 1, 4, 2, 3, 4, 4, 3, 5
    ] );

    var geometry = new THREE.BufferGeometry();
    geometry.addAttribute('position', new THREE.BufferAttribute( vertices, 3 ) );
    geometry.addAttribute('myColor', new THREE.BufferAttribute( colors, 3 ) );
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));

    // material for testing
    // var material = new THREE.MeshBasicMaterial({
    //   color: 0x505050,
    //   side: THREE.DoubleSide,
    //   polygonOffset: true,
    //   polygonOffsetFactor: 0.95, // positive value pushes polygon further away
    //   polygonOffsetUnits: 1
    // });

    var material = new THREE.ShaderMaterial( {
      uniforms: {
        time: { value: 1.0 },
        resolution: { value: new THREE.Vector2() }
      },
      vertexShader: document.getElementById( 'vertexShader' ).textContent,
      fragmentShader: document.getElementById( 'fragmentShader' ).textContent
    } );


    material.uniforms.resolution.value.x = window.innerWidth;
    material.uniforms.resolution.value.y = window.innerHeight;
    
    var mesh = new THREE.Mesh( geometry, material );
    scene.add(mesh);
    
    console.log(geometry.attributes.position.count);
    console.log(indices.length);

    var geo = new THREE.WireframeGeometry( geometry );
    var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } );
    var wireframe = new THREE.LineSegments( geo, material );
    scene.add( wireframe );

    camera.position.z = 100;

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild(renderer.domElement);

    function render() {
      requestAnimationFrame( render );
      renderer.render( scene, camera );
    }

    render();

    console.log(material.program.getAttributes());
    console.log(material.program.getUniforms());

  }
    /*

    camera = new THREE.OrthographicCamera(-10, 10, -10, 10, 1, 1000);
    //camera.position.z = 100;

    scene.add(new THREE.AmbientLight(0x444444));
    var light1 = new THREE.DirectionalLight(0xffffff, 0.5);
    light1.position.set(1.0, 1.0, 1.0);
    scene.add(light1);

    var geometry = new THREE.BufferGeometry();
    // create a simple square shape. We duplicate the top left and bottom right
    // vertices because each vertex needs to appear once per triangle.
    var vertices = new Float32Array( [
      -1.0, -1.0,  1.0,
       1.0, -1.0,  1.0,
       1.0,  1.0,  1.0,

       1.0,  1.0,  1.0,
      -1.0,  1.0,  1.0,
      -1.0, -1.0,  1.0
    ] );

    indices = new Uint32Array( 2 * 3 );

    // itemSize = 3 because there are 3 values (components) per vertex
    geometry.addAttribute('position', new THREE.BufferAttribute( vertices, 3 ) );
    geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );

    var material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
    var mesh = new THREE.Mesh( geometry, material );
    scene.add(mesh);

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio);

    container.appendChild(renderer.domElement);

    render();
  }

  function render() {
    renderer.render(scene, camera);
  }
*/
/*

  var container;
  var camera, scene, renderer;
  var uniforms;

  init();

  function init () {
    container = document.getElementById('container');

    camera = new THREE.Camera();
    camera.position.z = 1;

    scene = new THREE.Scene();
    
    var step = 1.0 / particles;
    var width = 10;
    var height = 10;
    var particles = width * height;
    var points = [];
    var positions = new Float32Array(particles * 3);
    var normals = new Float32Array(particles * 3);
    var colors = new Float32Array(particles * 3);

    for (var i = 0; i < particles; i++) {
      var idx = i * 3;
      var x = Math.random();
      var y = Math.random();
      var z = 0;
      points.push([x, y]);
      positions[idx + 0] = x;
      positions[idx + 1] = y;
      positions[idx + 2] = z;
      normals[idx + 0] = 0;
      normals[idx + 1] = 0;
      normals[idx + 2] = 0;
      colors[idx + 0] = 0.5 + x / 2;
      colors[idx + 1] = 0.5 + y / 2;
      colors[idx + 2] = 0.5 + z / 2;
    }

    var triangles = triangulate(points);
    var trigs = [];
    // convert array of arrays to a flat array
    for (var i = 0; i < triangles.length; i++) {
      var t = triangles[i];
      trigs.push(t[0], t[1], t[2]);
    }


    var geom = new THREE.BufferGeometry();

    geom.addAttribute('position', new THREE.BufferAttribute(positions, 3))
    geom.addAttribute('normal', new THREE.BufferAttribute(normals, 3))
    geom.addAttribute('color', new THREE.BufferAttribute(colors, 3))
    geom.setIndex(trigs);

    
    //console.log(triangles);

    // triangles is an array of arrays, containing the indices of points forming a triangle

    renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);

    container.appendChild(renderer.domElement);

  }
*/
</script>
</body>
</html>
